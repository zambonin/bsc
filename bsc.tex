\documentclass[12pt]{report}

\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, margin=2.75cm]{geometry}
\usepackage[colorlinks, urlcolor=blue, citecolor=red]{hyperref}
\usepackage[portuguese, onelanguage]{algorithm2e}
\usepackage{amsmath, amsfonts, enumitem, parskip, tikz, tikz-qtree, xfrac}

\usepackage{todonotes}

\usetikzlibrary{matrix, arrows, decorations.markings}

\newcommand{\hh}{\mathcal{H}}
\newcommand{\pk}{\mathcal{P}_k}
\newcommand{\sk}{\mathcal{S}_k}
\newcommand{\hash}[2][]{\mathcal{H}^{#1}(#2)}
\newcommand{\concat}{\, \vert \vert \,}
\newcommand{\binwds}[1]{\{0, 1\}^{#1}}
\newcommand{\length}[1]{\vert #1 \vert}
\newcommand{\fhash}[1]{\hh{} : \binwds{*} \longrightarrow \binwds{#1}}

\def\precircle{(0.00, 0) circle (1.25cm)}
\def\seccircle{(1.75, 0) circle (1.25cm)}
\def\colcircle{(1.75, 0) circle (0.75cm)}

\colorlet{circle edge}{black!50}
\colorlet{circle area}{black!35}

\tikzset{
  filled/.style={fill=circle area, draw=circle edge, thick},
  outline/.style={draw=circle edge, thick},
  SpongePerm/.style={rounded corners=4pt},
  XOR/.style={draw,circle,append after command={
    [shorten >=\pgflinewidth, shorten <=\pgflinewidth,]
    (\tikzlastnode.north) edge (\tikzlastnode.south)
    (\tikzlastnode.east) edge (\tikzlastnode.west)}},
  edge/.style={->},
  edgee/.style={<->},
  level distance=45pt,
  sibling distance=25pt
}

\title{
  Otimização de desempenho
  do esquema de assinatura digital única Winternitz
}
\author{Gustavo Zambonin}
\date{}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introdução}

A aplicação de protocolos criptográficos é essencial no contexto da validação e
proteção de quaisquer comunicações realizadas por um conjunto de entidades,
sejam estas dispositivos eletrônicos ou indivíduos, em virtude da possível
criticalidade e sensibilidade atribuídas aos dados transmitidos. Esquemas de
assinatura digital são comumente utilizados para assegurar este processo de
maneira formal~\cite{Goldreich:2004:FCV:975541}, através da autenticidade e
não-repúdio do remetente e certeza da integridade dos dados, a fim de traduzir
o resguardo provido por uma assinatura de próprio punho no mundo real.

Na prática, a maior parte destes esquemas utilizam como alicerce algorítmico
criptossistemas assimétricos baseados em problemas ``difíceis'' da teoria dos
números, como a fatoração de inteiros ou resolução do logaritmo discreto.
Este fato provê a segurança necessária para os esquemas
em computadores clássicos (eletrônicos), por conta da inexistência de
algoritmos que resolvem estes problemas em tempo polinomial, até o momento.
Entretanto, em computadores quânticos, algoritmos dessa forma já existem -- em
especial, o algoritmo de Shor~\cite{Shor:1997:PAP:264393.264406} --
efetivamente tornando estes esquemas clássicos inseguros neste novo contexto.

Para combater esta situação, a \emph{criptografia pós-quântica} encarrega-se de
buscar algoritmos criptográficos cuja segurança é considerada ``suficiente'',
mesmo utilizando-se de um computador quântico para ataques especializados. Esta
área conta com diversas abordagens: a criptografia baseada em reticulados,
polinômios de múltiplas variáveis sobre um corpo finito, teoria de códigos,
morfismos entre curvas elípticas supersingulares e criptossistemas simétricos.
Entretanto, reduções de segurança formais não existem para alguns destes
métodos, e para outros, o tamanho das chaves impossibilita a utilização destes
em aplicações práticas~\cite{Bernstein2017}.

Não obstante, uma abordagem adicional de esquema de assinatura digital
resistente a computadores quânticos é baseada apenas em funções de
resumo criptográfico, construídas a partir de funções de mão
única~\cite{cryptoeprint:2005:328}. De fato, estas funções, desde que
apresentem requisitos de segurança como resistência à segunda pré-imagem e/ou
à colisões, são necessárias e suficientes para a construção de esquemas bem
comportados e seguros~\cite{Rompel:1990:OFN:100216.100269}. Visto que estas
funções são estudadas exaustivamente por conta de sua vasta presença em
diversos âmbitos da segurança da informação, reduções de segurança são mais
comuns em relação a outras abordagens pós-quânticas, e tamanhos de chaves e
assinaturas não são proibitivos.

Esquemas de assinatura digital baseados em funções de resumo criptográfico
consistem da utilização de um esquema de assinatura digital \emph{única}, onde
apenas uma mensagem pode ser assinada de modo seguro, ou sua combinação com a
estrutura de dados chamada de árvore de Merkle~\cite{Merkle:1989:CDS:118209.118230},
que abriga pares de chaves de diversas instâncias
do esquema supracitado como suas folhas, e reduz a verificação destes para uma
única chave, codificada em sua raiz. Esta árvore é construída com a
concatenação de resumos criptográficos do conteúdo dos nós, habilitando assim a
assinatura de diversas mensagens. Como uma função específica não é necessária,
é possível obter uma grande variedade de esquemas, garantindo a versatilidade
destas abordagens.

Embora os esquemas iniciais tenham sido construídos sem atenção particular à
eficiência de modo geral (e.g. o esquema de assinatura única de
Lamport~\cite{lamport1979constructing} assina apenas um \emph{bit}
de informação em sua forma mais simples), muitos resultados práticos demonstram
a redução contínua do tempo de verificação da assinatura, tamanho e tempo para
geração do par de chaves e assinatura, bem como avanços teóricos que
possibilitam a utilização de funções com requisitos de segurança 
mínimos~\cite{Hlsing2013}, garantem o conceito de sigilo
encaminhado~\cite{Buchmann:2011:XPF:2184003.2184011} (i.e. comprometimento de
uma chave não implica na segurança de mensagens que utilizaram esta chave
anteriormente) e da ausência de estado~\cite{Bernstein2015} (i.e. esquema não
necessita registrar quais chaves de assinatura única já foram utilizadas).

Neste trabalho, foca-se no esquema de assinatura digital única Winternitz, e
apresenta-se uma customização para o esquema na forma de um parâmetro extra,
que habilita a redução da complexidade de verificação de assinatura em troca
do aumento desta na geração da assinatura, ou vice-versa. Ademais, as
consequências desta otimização são verificadas em esquemas mais complexos,
baseados em árvores de Merkle. Este trabalho é uma versão expandida,
e portanto didática, do artigo a ser publicado como~\cite{Peri1806:Tuning}.

\section{Objetivos}

\emph{Objetivo geral.} Apresentar um estudo detalhado sobre o esquema de
assinatura digital única Winternitz, contextualizando-o junto ao estado da
arte, observando o refinamento e utilização deste em vários outros esquemas a
fim de habilitar o gerenciamento de múltiplas assinaturas, fundamentando a
otimização proposta, que afeta o tempo de execução da criação ou
verificação de uma assinatura.

\emph{Objetivos específicos.} Descrever os esquemas de assinatura digital única
Lamport e Winternitz, e sua variante \textsc{Wots+}. Descrever os esquemas de
assinatura digital baseados em árvores de Merkle: \emph{Merkle Signature
Scheme}, e as famílias XMSS e SPHINCS. Discutir as consequências da modificação
do esquema Winternitz no contexto destes, e mensurar desempenho onde aplicável.

\chapter{Primitivas criptográficas}

Neste capítulo, são explicados os conceitos necessários
a fim de entender inteiramente um esquema de assinatura digital, bem como outros
algoritmos discutidos ao longo do trabalho. A organização das seções assemelha-se
à seguida em~\cite{Gathen:2015:CRY:2857293}. Os conceitos de criptografia simétrica
e assimétrica são apresentados, e uma simples comparação entre os mesmos é realizada, 
bem como exemplos apresentados na forma dos algoritmos AES e RSA, amplamente
padronizados e implementados em diversas formas de comunicação segura. Também é
discutida a função de resumo criptográfico, utilizada para que o processo de assinatura
seja menos custoso e mais seguro, e um exemplo de construção teórica por trás
deste tipo de função; e, por fim, a definição formal de um esquema de assinatura
digital agregando estas noções.

\section{Criptografia simétrica e assimétrica}

Define-se criptografia como a criação e análise de protocolos
matemáticos que habilitam comunicação segura, através de um canal
inseguro, entre duas ou mais entidades. Implementações destes,
comumente chamadas de algoritmos criptográficos,
podem ser parametrizadas por uma chave, que habilita a transformação
do texto plano para texto cifrado de acordo
com esta, de maneira individual e inteligível, mas a fim de tornar o
resultado irrecuperável sem a apresentação da chave correspondente.
Neste âmbito, é possível classificá-los em duas grandes famílias.

Sistemas que utilizam a mesma chave para as operações de codificação
e decodificação são chamados de simétricos. Nesta situação, a chave
representa um segredo compartilhado entre entidades desejando
estabelecer comunicação segura. Como o ato de compartilhar
este segredo necessita, por si próprio, de um canal seguro,
identifica-se neste aspecto uma desvantagem destes criptossistemas.

Cifras de bloco (DES, AES) ou de fluxo (RC4, Salsa20) são
considerados exemplos convencionais de criptossistemas simétricos.
A construção destes geralmente dá-se pelo encadeamento de operações
binárias e matemáticas favoráveis para computadores, assim permitindo
aos algoritmos um desempenho altíssimo. Utilizando estas como alicerce,
é possível construir funções de resumo criptográfico (a serem discutidas
em breve): por exemplo, a construção Merkle-Damgård, base para as funções
MD5, SHA1 e SHA2, utiliza uma função de compressão de mão única, obtida
a partir de uma cifra de bloco~\cite[9.41]{Menezes:1996:HAC:548089}.

No contexto da computação quântica, estes sistemas são ameaçados
pelo algoritmo de Grover~\cite{Grover:1996:FQM:237814.237866}, que
possibilita a busca de elementos em conjuntos em tempo reduzido.
Por outra forma, suponha que deseja-se inverter uma função $f : A
\longrightarrow B$, a partir de um elemento $b \in B$. Classicamente,
como não existe informação qualquer sobre a função, é necessário
calcular $f$ para cada um dos elementos de seu domínio (i.e. $\length{A}$
vezes). Entretanto, Grover permite que esta busca seja feita em
$\length{A}^{\frac{1}{2}}$ operações. Assim, um algoritmo criptográfico simétrico
que toma o lugar de $f$, neste exemplo, precisa de parâmetros de segurança
maiores, a fim de igualar a dificuldade da busca tratando-se de um
computador clássico.

Em contrapartida, a criptografia assimétrica, ou criptografia de chaves
públicas, engloba os algoritmos que utilizam um par de chaves: a chave privada
($\sk{}$), conhecida apenas pela entidade que a gerou, e a chave pública
($\pk{}$), distribuída livremente. Isto possibilita o uso livre de $\pk{}$ para
a comunicação segura com o detentor da chave sem a necessidade de um canal
seguro, em virtude da construção dos algoritmos.

A ideia foi introduzida abstratamente em~\cite{Diffie:2006:NDC:2263321.2269104}
e tem como exemplos algoritmos como RSA, ElGamal e ECDSA.
Diferentemente dos algoritmos simétricos, estes sistemas utilizam operações
mais robustas, e portanto de desempenho reduzido. Assim, a utilização
convencional destes dois tipos de criptografia em protocolos se dá pela
codificação de uma chave simétrica (responsável por cifrar um documento
de tamanho não-trivial) com uma chave pública -- e portanto,
assimétrica -- e transmissão desta ``chave cifrada'' sem a necessidade de
um canal seguro.

A segurança de sistemas assimétricos depende da ``dificuldade''
computacional de determinar uma chave privada a partir da chave pública,
e também do armazenamento de $\sk{}$ em um lugar seguro. Problemas em
teoria de números e álgebra que atualmente não admitem soluções em tempo
polinomial são comumente utilizados como base para algoritmos assimétricos.
Porém, percebe-se que, com a introdução de um computador quântico, estes
problemas podem ser resolvidos de maneira significativamente mais rápida,
como visto em~\cite{Shor:1997:PAP:264393.264406}.

\subsection{AES --- \emph{Advanced Encryption Standard}}

Originalmente publicado como Rjindael, o algoritmo conhecido como AES é resultado
de um esforço de padronização para um sistema criptográfico seguro, finalizado
ao término do século XX pelo NIST~\cite{Standards2001} (\emph{National Institute
of Standards and Technology}), a fim de substituir a cifra DES.
Definido como uma cifra de blocos iterativa, opera
sobre uma matriz de estado $A$, onde $A_{i,j} \in 
\mathbb{F}_{2^{8}}$\footnote{Definido pelo polinômio irredutível
$m(x) = x^{8} + x^{4} + x^{3} + x + 1$. Adições e multiplicações em corpos da
forma $\mathbb{F}_{2^n}$ são análogas a operações computacionais extremamente
baratas. e , tornando esta},
$0 \leq i, j < 4$, a partir de uma chave $K$ de tamanho $n \in \{128, 192,
256\}$. Consiste em aplicações sequenciais de quatro operações ordenadas
(\textsc{SubBytes}, \textsc{ShiftRows}, \textsc{MixColumns} e
\textsc{AddRoundKey}) sobre $A$. A quantidade destas aplicações, denominadas
rodadas ($n_r$), depende diretamente do tamanho da chave: $n = 128 \rightarrow
n_r = 10, n = 192 \rightarrow n_r = 12, n = 256 \rightarrow n_r = 14$.

Note que existe uma rodada adicional introdutória composta apenas de
\textsc{AddRoundKey}, para que o estado inicial seja modificado. Ademais,
\textsc{MixColumns} é ignorado na última rodada, a fim de facilitar a
reversibilidade da cifra. Uma rotina de expansão de chave
(\textsc{KeyExpansion}) existe para que $K$ seja propagada em todas as rodadas
com valores derivados, porém distintos. Estes componentes serão descritos
abaixo.

\begin{enumerate}[label=\roman*.]

  \item \textsc{SubBytes}: realiza-se a reposição de $A_{i,j}$ pelo seu valor
      correspondente em uma \emph{substitution-box} (\emph{S-box}, construída a
        partir de uma transformação afim em $A_{i,j}^{-1}$),
        onde os \emph{nibbles} mais e menos significativos,
        respectivamente, representam a linha e a coluna do elemento na
        \emph{S-box}.

  \item \textsc{ShiftRows}: cada linha de $A$, $A_i$, é deslocada circularmente
      à esquerda $i$ vezes.

  \item \textsc{MixColumns}: cada coluna de $A$, $A_j$, é multiplicada pelo
      polinômio $c = 03 \cdot x^{3} + 01 \cdot x^{2} + 01 \cdot x + 02$, módulo
        $x^{4} + 1$, para que o resultado ainda seja um polinômio de grau
        máximo 3, apto a ser representado na coluna.

  \item \textsc{AddRoundKey}: a operação \texttt{XOR} bit a bit é aplicada
      entre $A$ e o bloco da chave referente à rodada.

\end{enumerate}

\textsc{KeyExpansion} consiste da criação de um conjunto de palavras $K_e$ de
32 bits.  Tome $\ell = \frac{n}{32}$, e assumindo que é necessário criar
palavras suficientes para utilização em todas as rodadas do algoritmo, então $t
= \ell \cdot (n_r + 1)$ e $K_e = \{k_0, \dots, k_{t - 1}\}$. Também defina
$rot(x)$ como o deslocamento circular à esquerda de 8 bits da palavra $x$, e a
lista de constantes $RC$ com elementos em $\mathbb{F}_{2^{8}}$ é definida pela
recursão $RC_0 = x^0, RC_1 = x^1, RC_j = x^{j-1} \cdot RC_{j-1}, j > 2$.
Inicialmente, $K$ é dividida em $\ell$ palavras, que compõem o começo de $K_e$.
Para os elementos restantes, ou seja, $\forall i \geq \ell$,
\begin{equation}
  k_{i} = k_{i - \ell} \oplus 
    \begin{cases}
      \textsc{SubBytes}(rot(k_{i - 1})) \oplus RC_{\frac{i}{\ell}},
        \text{ se } i \equiv 0 \pmod{4} \\
      \textsc{SubBytes}(k_{i - 1}),
        \text{ se } \ell = 8 \text { e } i \equiv 4 \pmod{8} \\
      k_{i - 1}, \text{ caso contrário.}
    \end{cases}
\end{equation}
Assim, uma função que criptografa uma mensagem $m$ e retorna um texto cifrado
$c$ pode ser representada pelo Algoritmo~\ref{alg:1}. A mensagem é primeiramente
codificada em $A$ da seguinte maneira: $A_{i, j} = m_{i + 4j}, 0 \leq i, j < 4$.

\begin{algorithm}[H]
  \small
  \KwData{$m$, o texto a ser cifrado; $K$, a chave desejada}
  \KwResult{$c$, o texto cifrado resultante}

  $A \leftarrow m$\;
  $\{k_{0} \dots k_{(n_r + 1) \cdot \ell}\}
    \leftarrow \textsc{KeyExpansion}(K)$\;
  $A \leftarrow \textsc{AddRoundKey}(A,
    \{k_{0}, \dots, k_{\ell - 1}\})$\;

  \For{$i \leftarrow 1$ \KwTo $n_r - 1$}{
    $A \leftarrow \textsc{SubBytes}(A)$\;
    $A \leftarrow \textsc{ShiftRows}(A)$\;
    $A \leftarrow \textsc{MixColumns}(A)$\;
    $A \leftarrow \textsc{AddRoundKey}(A,
      \{k_{i \cdot \ell}, \dots, k_{(i + 1) \cdot \ell - 1}\})$\;
  }

  $A \leftarrow \textsc{SubBytes}(A)$\;
  $A \leftarrow \textsc{ShiftRows}(A)$\;
  $A \leftarrow \textsc{AddRoundKey}(A,
    \{k_{n_r \cdot \ell}, \dots, k_{(n_r + 1) \cdot \ell - 1}\})$\;

  $c \leftarrow A$\;
  \caption{Algoritmo de codificação do AES.}
  \label{alg:1}
\end{algorithm}

Para que a cifra seja caracterizada como simétrica, é preciso criar uma função
que faça o inverso do procedimento acima. Assim, suas etapas precisam ser
modificadas de acordo.

\begin{enumerate}[label=\roman*.]

  \item \textsc{InvShiftRows}: cada linha de $A$, $A_i$, é deslocada
      circularmente à direita $i$ vezes.

  \item \textsc{InvSubBytes}: é necessário computar a transformação afim
      inversa para cada elemento $A_{i,j}$, e depois calcular sua inversa
        multiplicativa.

  \item \textsc{InvMixColumns}: cada coluna de $A$, $A_j$, é multiplicada pela
      inversa multiplicativa $d = c^{-1}$, obtida por: $(03 \cdot x^{3} + 01
        \cdot x^{2} + 01 \cdot x + 02) \cdot d \equiv 1 \pmod{x^{4} + 1}$, logo
        $d(x) = 0B \cdot x^{3} + OD \cdot x^{2} + 09 \cdot x + 0E$.

\end{enumerate}

Por fim, o algoritmo resultante pode ser representado pelo Algoritmo~\ref{alg:2}.
Note a mudança da ordem das etapas, e a utilização invertida de $K_e$. $c$ é
codificado no estado de maneira análoga ao algoritmo anterior.

\begin{algorithm}[H]
  \small
  \KwData{$c$, o texto cifrado; $K$, a chave desejada}
  \KwResult{$m$, o texto claro resultante}

  $A \leftarrow c$\;
  $\{k_{0} \dots k_{(n_r + 1) \cdot \ell}\}
    \leftarrow \textsc{KeyExpansion}(K)$\;
  $A \leftarrow \textsc{AddRoundKey}(A,
    \{k_{n_r \cdot \ell}, \dots, k_{(n_r + 1) \cdot \ell - 1}\})$\;

  \For{$i \leftarrow n_r - 1$ \KwTo $1$}{
    $A \leftarrow \textsc{InvShiftRows}(A)$\;
    $A \leftarrow \textsc{InvSubBytes}(A)$\;
    $A \leftarrow \textsc{AddRoundKey}(A,
      \{k_{i \cdot \ell}, \dots, k_{(i + 1) \cdot \ell - 1}\})$\;
    $A \leftarrow \textsc{InvMixColumns}(A)$\;
  }

  $A \leftarrow \textsc{InvShiftRows}(A)$\;
  $A \leftarrow \textsc{InvSubBytes}(A)$\;
  $A \leftarrow \textsc{AddRoundKey}(A,
    \{k_{0}, \dots, k_{\ell - 1}\})$\;

  $m \leftarrow A$\;
  \caption{Algoritmo de decodificação do AES.}
  \label{alg:2}
\end{algorithm}

Para discussões detalhadas sobre as etapas do algoritmo, a fundamentação
algébrica por trás deste, escolhas feitas em cada etapa, criptoanálise
relacionada e outros tópicos avançados, mostra-se razoável consultar
o livro original de descrição do AES~\cite{Daemen:2002:DR:560131}.

\subsection{O criptossistema RSA}

O algoritmo conhecido como RSA~\cite{Rivest:1978:MOD:359340.359342} é uma
implementação de criptografia assimétrica amplamente utilizada. É baseado na
dificuldade de fatorar o produto de dois números primos suficientemente
grandes\footnote{O algoritmo é baseado no problema RSA, definido como realizar
uma operação de chave privada no algoritmo RSA utilizando apenas $\pk{}$.
Acredita-se que este problema seja equivalente à fatoração de
inteiros~\cite[3.30]{Menezes:1996:HAC:548089}.}. Em virtude de seu baixo
desempenho computacional, geralmente apenas um resumo criptográfico da mensagem
desejada é codificado por este algoritmo, e sua transmissão é realizada
junto à mensagem original, de forma concatenada. Abaixo, uma descrição do
funcionamento do algoritmo. Tome $\phi(x)$ como a função totiente de Euler, que
representa a quantidade de números relativamente primos a $x$.

\begin{enumerate}

  \item[] \emph{Geração de chaves.} Gere dois números primos $p, q$
      aleatoriamente, suficientemente grandes e de tamanhos similares. Compute
        $n = p q$ e $\phi(n) = (p - 1) (q - 1)$. Selecione um número aleatório
        $e$ relativamente primo a $\phi(n)$. Então, use o algoritmo de Euclides
        estendido para computar $d$ tal que $ed \equiv 1 \pmod{\phi(n)}$), i.e.
        a inversa multiplicativa modular de $e$. Finalmente, $\mathcal{S}_k =
        d$ e $\mathcal{P}_k = (n, e)$.

  \item[] \emph{Codificação.} Obtém-se $\pk{}$ da entidade para qual deseja-se
      criptografar uma mensagem. Transforma-se uma mensagem $m$ em um inteiro
        no intervalo $[0, n - 1]$ através de uma função de preenchimento.  O
        texto cifrado $c = m^e \pmod{n}$ é calculado através de um algoritmo
        como a exponenciação quadrática e enviado para a entidade desejada.

  \item[] \emph{Decodificação.} O receptor da mensagem calcula $m = c^d
      \pmod{n}$.

  \item[] \emph{Demonstração.} Para demonstrar $m^{ed} \equiv m \pmod{n}$, é
      suficiente mostrar que $m^{ed} \equiv m \pmod{p}$ e $m^{ed} \equiv m
        \pmod{q}$, pelo Teorema Chinês do Resto. Se $m \equiv 0 \pmod{p}$,
        então $gcd(m, p) = p$ e certamente $m^{ed} \equiv 0 \equiv m \pmod{n}$.
        Se $m \not\equiv 0 \pmod{p}$, então $mdc(m, p) = 1$ e pelo Pequeno
        Teorema de Fermat, $m^{p - 1} \equiv 1 \pmod{p}$. Reescrevendo o
        produto $ed$ como $ed = 1 + y\phi(n) = 1 + y(p - 1)(q - 1), \; y \in
        \mathbb{N}$, então
        \begin{equation}
          m^{ed} \equiv m^{1 + y(p-1)(q-1)} \equiv
            (m^{p-1})^{y(q-1)}m \equiv 1^{y(q-1)}m \equiv m \pmod{p}.
        \end{equation}
        Analogamente, substituindo $p$ por $q$ no argumento acima, tem-se a
        prova que $\forall m \in \mathbb{N}, \; m^{ed} \equiv m \pmod{n}$.

\end{enumerate}

Nota-se que a descrição acima, embora funcional, apresenta sérios problemas de
segurança se implementada de maneira ingênua. Defina a noção de segurança
semântica como, dado um texto cifrado, a impossibilidade de revelar
informações quaisquer sobre seu texto plano
correspondente~\cite{Goldwasser:1982:PEA:800070.802212}. Observe, por exemplo,
que não existe qualquer fator aleatório na codificação da mensagem,
caracterizando-a como determinística e habilitando uma entidade
maliciosa a aplicar um ataque de texto plano escolhido, i.e. a codificação
de múltiplas mensagens a fim de descobrir informações sobre o algoritmo
baseado em semelhanças entre as mensagens cifradas, portanto semanticamente
inseguro. Este e outros ataques~\cite{Boneh99twentyyears} são mitigados com
a aplicação de uma função de preenchimento à mensagem~\cite{Bellare1995}.

\section{Funções de resumo criptográfico}

Funções criadas com o intuito de resumir dados, ou seja, reduzir uma mensagem
de tamanho arbitrário para uma palavra pequena e identificável
deterministicamente, podem possuir várias propriedades, apresentadas abaixo de
acordo com~\cite[9.2]{Menezes:1996:HAC:548089}.  Tome uma função $\mathcal{H} :
X \longrightarrow Y$. Comumente, os elementos de $Y$ são chamados de resumos. É
importante notar que um problema é considerado ``difícil'', ou
computacionalmente inviável, quando o tempo ou recursos gastos para esta
computação excedem a validade ou utilidade da informação desejada.

\begin{enumerate}[label=(\roman*)]

  \item O cálculo de todo resumo deve ser \emph{computacionalmente fácil};

  \item $\hh{}$ deve apresentar \emph{compressão}, ou seja, $\forall x \in X, y
      \in Y, \length{x} > \length{y}$;

  \item $\hh{}$ pode apresentar \emph{resistência à pré-imagem} (\textsc{Pre}),
      caracterizada pelo seguinte comportamento: fornecido um resumo $h \in Y$,
        é computacionalmente inviável achar a mensagem original $m \in X$ que
        gerou $h$ através de $\hash{m} = h$;

  \item $\hh{}$ pode apresentar \emph{resistência à segunda pré-imagem}
      (\textsc{Sec}), caracterizada pelo seguinte comportamento: fornecida uma
        mensagem $m_0 \in X$, é computacionalmente inviável achar uma mensagem
        $m_1 \in X$ tal que $m_0 \neq m_1$ e $\hash{m_0} = \hash{m_1}$;

  \item $\hh{}$ pode apresentar \emph{resistência à colisões} (\textsc{Col}),
      caracterizada pelo seguinte comportamento: é computacionalmente inviável
        encontrar quaisquer duas mensagens $m_0, \; m_1 \in X$ e $m_0 \neq
        m_1$, de forma que $\hash{m_0} = \hash{m_1}$;

  \item $\hh{}$ pode ser parametrizada por uma chave $k$.  Este comportamento
      pode ser representado por $\hh{}_k$.

\end{enumerate}

É possível classificar $\hh{}$ de acordo com a presença destas propriedades.
Uma função de resumo simples contém apenas (i) e (ii). Ao adicionar (iii) e
remover (i), obtém-se uma função de mão única, onde o cálculo de $\hh{}^{-1}$ é
computacionalmente inviável. Uma função de resumo de mão única é obtida com as
quatro primeiras propriedades. Por fim, uma função de resumo resistente à
colisões, ou \emph{função de resumo criptográfico}, conta com as cinco
primeiras propriedades, que tornam-a adequada para utilização no contexto de
segurança da informação.

Estas possibilitam a certeza da integridade de dados, mesmo que armazenados em
um dispositivo inseguro. Mostra-se desejável, intuitivamente, que não ocorra
uma relação aparente entre entradas e saídas da função, tratando-se da do
resumo por completo e subseções deste.  Outra característica desejada é o
efeito avalanche, baseado no conceito de
difusão~\cite{Stallings:2010:CNS:1824151}: trocar apenas um \emph{bit} da
mensagem $m$ deve modificar cerca de metade dos \emph{bits} do resumo, e
vice-versa.

Adicionalmente, discute-se brevemente a relação da propriedade (vi) com funções
de resumo. Funções de compressão de mão única não admitem o título de funções
de resumo, visto que a propriedade de compressão não é respeitada -- embora seu
nome leve a erro, neste caso, $\length{X}$ é fixo. Porém, podem ser
parametrizadas por uma chave, e são utilizadas para a construção de cifras de
bloco~\cite[9.25]{Menezes:1996:HAC:548089}. Códigos de autenticação de
mensagens, por outro lado, geralmente englobam todas as seis propriedades, pois
funções de resumo criptográfico são utilizadas em sua construção, e a
parametrização habilita autenticação da mensagem junto à integridade já
fornecida.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \begin{scope}[fill opacity=0.5]
      \clip \precircle;
      \fill[filled] \seccircle;
      \fill[filled] \colcircle;
    \end{scope}
    \draw[outline] \precircle node {\textsc{Pre}};
    \draw[outline] \seccircle node {};
    \draw[outline] \colcircle node {\textsc{Col}};
    \draw node at (1.75, 1) {\textsc{Sec}};
  \end{tikzpicture}
  \caption{Diagrama de Venn das resistências desejáveis para uma função de
    resumo no contexto de assinaturas digitais.}
  \label{fig:1}
\end{figure}

Ademais, note que \textsc{Sec} e \textsc{Col} apresentam uma sutil diferença:
na primeira, um adversário não pode escolher $m_0$, enquanto na segunda,
quaisquer pares de mensagens podem ser testados. A resistência à colisão,
portanto, implica na resistência à segunda pré-imagem, visto que basta um
adversário fixar $m_0$ para simular o cômputo de $m_1$.

Na Figura \ref{fig:1}, estão destacados os requisitos comuns para a utilização
de funções de resumo no contexto de esquemas de assinatura digital, em vista da
possibilidade de uma entidade maliciosa, geralmente chamada de adversário,
desejar produzir assinaturas forjadas. É possível constatar que, embora exista
uma divisão estrita entre \textsc{Pre} e \textsc{Sec}, observa-se que na
prática, assume-se que a segunda implica a primeira resistência
\cite[9.20]{Menezes:1996:HAC:548089}.

Enumeram-se algumas aplicações comuns para estas funções: a verificação da
integridade de um arquivo, i.e. determinar se mudanças neste foram feitas ao
longo de uma transmissão, ou qualquer outro evento; a fim de evitar o
armazenamento de senhas em texto plano, é possível manter apenas o resumo
criptográfico destas, e no momento da autenticação do usuário perante o
serviço, comparar apenas estes resumos\footnote{É possível armazenar tabelas de
resumos pré-computados a fim de atacar serviços que não empregam uma maneira
mais elaborada de autenticação (i.e. um valor pseudoaleatório concatenado ao
resumo criptográfico da senha do usuário).}; resumos criptográficos são
comumente empregados como identificadores únicos para um arquivo (e.g.
\emph{commits} em um sistema de controle de versões); entre outras aplicações,
como a geração de números pseudoaleatórios.

\subsection{Construção esponja}

A construção esponja \cite{SpongeReference}, de característica iterativa,
permite a generalização de funções de resumo, naturalmente com saídas de
tamanho fixo, para funções com saídas de tamanho arbitrário, baseadas em uma
função interna, geralmente uma permutação $f$ de tamanho fixo $b$. Este valor,
também chamado de largura, é composto da adição da taxa de \emph{bits} $r$ e da
capacidade $c$. Assim, a construção opera em um estado de $b = r + c$
\emph{bits}.

O estado inicial, análogo a um vetor de inicialização no contexto de algoritmos
criptográficos, não necessita de valores especiais e é ocupado com valores
nulos. A entrada $m$ é preenchida com uma função de preenchimento \texttt{pad}
de tal modo que $r \mid \length{m}$, e dividida em blocos de tamanho $r$. A
fase de absorção de $m$ pela esponja procede da seguinte maneira: a operação de
ou exclusivo ($\oplus$) é calculada entre os blocos e os estados da construção,
intercalados por aplicações de $f$.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[scale=0.5]
    \begin{scope}[xshift=0cm]
      \draw[thick] (0,0) rectangle ++(1,10);
      \draw[thick] (0,3) -- ++(1,0);
      \node[XOR,thick] (xm0) at (1+1.5,8) {};
      \draw[edge,thick] (1,8) -- (xm0);
      \draw[edge,thick] (1,2) -- ++(3,0);
      \draw[edge,thick] (1+1.5,10.5) node[above] {\large $m_{0}$} -- (xm0);
      \draw[edge,thick] (xm0) -- ++(1.5,0);
      \draw[edgee,anchor=east] (-1,3) -- node[left] {$r$} ++(0,7);
      \draw[edgee,anchor=east] (-1,0) -- node[left] {$c$} ++(0,3);
    \end{scope}
    \begin{scope}[xshift=4cm]
      \draw[SpongePerm] (0,0) rectangle node {\large$f$} ++(1,10);
      \node[thick] (xm1) at (1+1.5,8) {$\dots$};
      \draw[edge,thick] (1,8) -- (xm1);
      \draw[edge,thick] (xm1) -- ++(1.5,0);
      \node[thick] (xm1) at (1+1.5,2) {$\dots$};
      \draw[edge,thick] (1,2) -- (xm1);
      \draw[edge,thick] (xm1) -- ++(1.5,0);
    \end{scope}
    \begin{scope}[xshift=8cm]
      \draw[SpongePerm] (0,0) rectangle node {\large$f$} ++(1,10);
      \node[XOR,thick] (xm1) at (1+1.5,8) {};
      \draw[edge,thick] (1,8) -- (xm1);
      \draw[edge,thick] (1,2) -- ++(3,0);
      \draw[edge,thick] (1+1.5,10.5) node[above] {\large $m_{i}$} -- (xm1);
      \draw[edge,thick] (xm1) -- ++(1.5,0);
    \end{scope}
    \begin{scope}[xshift=12cm]
      \draw[SpongePerm] (0,0) rectangle node {\large$f$} ++(1,10);
      \draw[edge,thick] (1,2) -- ++(3,0);
      \draw[edge,thick] (1,8) -- ++(3,0);
    \end{scope}
    \begin{scope}[xshift=16cm]
      \draw[thick] (0,0) rectangle ++(1,10);
      \draw[thick] (0,3) -- ++(1,0);
      \draw[edge,thick] (1,2) -- ++(3,0);
      \draw[edge,thick] (1,8) -- ++(3,0);
      \draw[edge,thick] (1+1.5,8) -- ++(0,2.5) node[above] {\large $z_{0}$};
      \draw[dashed,thick] (-1.5,-1.5) -- ++(0,13);
    \end{scope}
    \begin{scope}[xshift=20cm]
      \draw[SpongePerm] (0,0) rectangle node {\large$f$} ++(1,10);
      \node[thick] (xm1) at (1+1.5,8) {$\dots$};
      \draw[edge,thick] (1,8) -- (xm1);
      \draw[edge,thick] (xm1) -- ++(1.5,0);
      \node[thick] (xm1) at (1+1.5,2) {$\dots$};
      \draw[edge,thick] (1,2) -- (xm1);
      \draw[edge,thick] (xm1) -- ++(1.5,0);
    \end{scope}
    \begin{scope}[xshift=24cm]
      \draw[SpongePerm] (0,0) rectangle node {\large$f$} ++(1,10);
      \draw[edge,thick] (1,8) -- ++(1.5,0) -- ++(0,2.5) node[above] {\large $z_{j}$};
    \end{scope}
  \end{tikzpicture}
  \caption{Descrição gráfica da construção
      esponja~\cite{TikZ:for:Cryptographers}, onde $i, j \in \mathbb{N}^{*}$.}
  \label{fig:3}
\end{figure}

Ao término do processamento dos blocos, a fase de compressão é iniciada, onde
$n$ blocos de tamanho $r$ compõem a saída da função, novamente intercalados por
aplicações de $f$, onde $n$ é parametrizável pelo usuário. Os últimos $c$ bits
do estado nunca são diretamente afetados pelos blocos, e também nunca revelados
durante a fase de compressão. Essencialmente, estão correlacionados com o nível
de segurança da construção esponja. Assim, uma função esponja pode ser definida
como $\textsc{Sponge}[f, \texttt{pad}, r]$, e sua representação gráfica pode
ser consultada em~\ref{fig:3}.

A função esponja \textsc{Keccak}~\cite{KeccakReference} é definida a partir
desta construção, e pode agir como uma função de resumo criptográfico. Existem
sete permutações passíveis de utilização nesta função: defina $w = 2^{\ell}, \;
\ell \in \{0, \dots, 6\}$.  Estas são chamadas de $\textsc{Keccak}-f[b]$, onde
$b = 25w$, cujo estado $a$ é descrito como uma estrutura tridimensional com
elementos em $\mathbb{F}_2$, de dimensões $5 \times 5 \times w$. Esta
permutação é iterativa e consiste de um número de rodadas
$n_R = 12 \times 2 \ell$. Cada rodada $R$, por sua vez, consiste da composição
de cinco etapas: $R = \iota \circ \chi \circ \pi \circ \rho \circ \theta$.

\begin{enumerate}

  \item[Etapa $\theta$:] Calcula o ou exclusivo entre um elemento de $a$ e
      todos os elementos das colunas adjacentes a este.

  \item[Etapa $\rho$:] Dispersa os elementos entre cortes transversais
      verticais de $a$.

  \item[Etapa $\pi$:] Rearranja elementos em cortes transversais horizontais de
      $a$.

  \item[Etapa $\chi$:] Modifica uma elemento de uma linha de $a$ de acordo com
      uma função não-linear de dois outros bits adjacentes. Análogo a uma
        caixa-S.

  \item[Etapa $\iota$:] Calcula o ou exclusivo entre o estado $a$ e uma
      sequência gerada por um \emph{linear-feedback shift register} alimentado
        pelo índice da rodada atual, tornando a rodada assimétrica.

\end{enumerate}

Tome \texttt{pad10*1} como uma função que gera palavras que iniciam e terminam
com $1$, e têm número não-negativo de zeros. Formalmente, para uma mensagem
qualquer $m$ e um tamanho de saída $d \in \mathbb{N}^{*}$, a função esponja é
definida como
\begin{equation}
  \textsc{Keccak}[r, c](m, d)
    = \textsc{Sponge}[\textsc{Keccak}-f[r + c], \texttt{pad10*1}, r]
\end{equation}
onde $r$ tem um valor padrão de $1600 - c$. Assim,
\begin{equation}
  \textsc{Keccak}[c] = \textsc{Keccak}[1600 - c, c].
\end{equation}
Finalmente, as funções padronizadas em~\cite{Dworkin2015} como a família SHA-3
são definições de \textsc{Keccak} com parâmetros fixos, e.g.
\begin{equation}
  \text{SHA3-}256(m) = \textsc{Keccak}[512](m \concat 01, 256).
\end{equation}

\section{Esquemas de assinatura digital}

Um esquema de assinatura digital é uma construção matemática que habilita a
demonstração de certas propriedades sobre mensagens assinadas: nomeadamente, a
autenticação do remetente, onde esta entidade pode ser facilmente identificada
como a emissora da assinatura digital; a integridade da mensagem, i.e. a
certeza de que esta não foi modificada ao ser transmitida por um canal
possivelmente inseguro; e o não-repúdio do remetente, onde não é possível negar
que uma mensagem foi assinada e enviada, após este fato.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \node (hm) at (-1.25, 0) {$m$};
    \node (in) at (0, -2) {$1^n$};
    \node (sk) at (0, -1) {$\sk{}$};
    \node (pk) at (4, -1) {$\pk{}$};
    \node (ds) at (2, 0) {$\sigma$};
    \node (res) at (5.5, 0) {\scriptsize $\binwds{}$};
    \node[draw] (sig) at (0, 0) {\textsc{Sig}};
    \node[draw] (gen) at (2, -2) {\textsc{Gen}};
    \node[draw] (ver) at (4, 0) {\textsc{Ver}};
    \draw[-latex] (gen) to (1.25, -1) to (sk);
    \draw[-latex] (gen) to (2.75, -1) to (pk);
    \draw[-latex] (sk) -- (sig);
    \draw[-latex] (hm) -- (sig);
    \draw[-latex] (sig) -- (ds);
    \draw[-latex] (ds) -- (ver);
    \draw[-latex] (pk) -- (ver);
    \draw[-latex] (ver) -- (res);
    \draw[-latex] (in) -- (gen);
  \end{tikzpicture}
  \caption{Funcionamento típico de um esquema de assinatura digital.}
  \label{fig:2}
\end{figure}

Esquemas de assinatura digital são fortemente baseados em criptografia de
chaves públicas, e consistem de três algoritmos: a geração de chaves
$\textsc{Gen}(1^n)$, que gera um par de chaves aleatório $(\mathcal{P}_k,
\mathcal{S}_k)$ com parâmetro de segurança $n \in \mathbb{N}^{*}$; o algoritmo
de assinatura $\textsc{Sig}(\mathcal{S}_k, m)$, que produz uma assinatura
$\sigma$ para uma mensagem $m$; e o algoritmo de verificação
$\textsc{Ver}(\mathcal{P}_k, m, \sigma)$, que retorna o estado de validade da
assinatura como um valor verdade binário. De acordo
com~\cite{Goldreich:2004:FCV:975541}, todas as assinaturas geradas por
\textsc{Sig} devem ser verificáveis por \textsc{Ver} utilizando todas as chaves
geradas por \textsc{Gen}. Formalmente, $\forall (p, s) \in \textsc{Gen}(1^n)$ e
$\forall w \in \binwds{*}$,
\begin{equation}
    \text{Pr}[\textsc{Ver}(p, w, \textsc{Sig}(s, w)) = 1] = 1.
\end{equation}
É necessário apontar que esta definição não considera a segurança do esquema --
é possível construir trivialmente algoritmos que respeitam a equação acima, sem
qualquer tipo de codificação a fim de ocultar mensagens.  Na Figura
\ref{fig:2}, é possível visualizar um diagrama do comportamento de um esquema
de assinatura digital genérico. Note que $\sigma$ geralmente é composta da
concatenação da mensagem original com a assinatura do resumo criptográfico
desta, embora a saída do algoritmo \textsc{Sig} consista apenas da aplicaç£o de
uma funÃ§Ã£o interna ao resumo.

Finalmente, a apresentaÃ§Ã£o de um exemplo de esquema de assinatura digital Ã©
postergado para as prÃ³ximas seÃ§Ãµes, onde serÃ£o explanados vÃ¡rios esquemas que,
embora teoricamente similares, habilitam o entendimento conceitual de vÃ¡rios
outros algoritmos com a mesma funÃ§Ã£o, mas execuÃ§Ãµes distintas.

\chapter{Assinatura digital baseada em funÃ§Ãµes de resumo criptogrÃ¡fico}

Neste capÃ­tulo, sÃ£o apresentados vÃ¡rios esquemas de assinatura digital Ãºnica
comeÃ§ando pelo original, Lamport, a fim de fundamentar o raciocÃ­nio por trÃ¡s
do esquema alvo. Winternitz e \textsc{Wots+} sÃ£o definidos logo apÃ³s. Esquemas
convencionais baseados em Ã¡rvores de Merkle, como o homÃ´nimo, XMSS
(\emph{eXtended Merkle Signature Scheme}) e sua variante multiÃ¡rvores
XMSS$^{MT}$, e SPHINCS sÃ£o abordados logo apÃ³s. Em especial, estes
esquemas sÃ£o escolhidos como os exemplos mais reconhecidos de suas respectivas
categorias.

\section{Esquemas de assinatura Ãºnica}

Esquemas de assinatura Ãºnica (\emph{one-time signature schemes}) possibilitam a
assinatura de apenas uma mensagem, facilitando a falsificaÃ§Ã£o deste processo no
caso da reutilizaÃ§Ã£o do par de chaves. SÃ£o construÃ§Ãµes fundamentais para a
criaÃ§Ã£o de esquemas baseados apenas em funÃ§Ãµes de resumo criptogrÃ¡fico --
vÃ¡rios esquemas continuam utilizando assinatura Ãºnica e compÃµem o estado da
arte da literatura~\cite{sphincsplus,irtf-cfrg-xmss-hash-based-signatures-12}.

\subsection{O esquema Lamport}

A utilizaÃ§Ã£o de funÃ§Ãµes de resumo criptogrÃ¡fico para a criaÃ§Ã£o de esquemas de
assinatura digital foi iniciada por Lamport~\cite{lamport1979constructing}
e estendida em~\cite{Diffie:2006:NDC:2263321.2269104, Merkle:1989:CDS:118209.118230},
permitindo assinar um \emph{bit} de cada vez para uma dada mensagem. O par de
chaves consiste de um par de palavras pseudoaleatÃ³rias $x_0, x_1$ como $\sk{}$,
e seus resumos como $\pk{}$. O assinante assina um \emph{bit} $b$ distribuindo
$x_b$, e o recipiente verifica se $\hash{x_b}$ Ã© o valor correto em $\pk{}$.
Como parte de $\sk{}$ Ã© distribuÃ­da, nÃ£o Ã© recomendÃ¡vel reutilizar o par de
chaves, e os elementos nÃ£o distribuÃ­dos devem ser destruÃ­dos. Assinar mensagens
mais longas envolve o cÃ¡lculo do resumo desta, visto que do contrÃ¡rio, o
tamanho do par de chaves e assinaturas torna-se extremamente proibitivo.

Formalmente, tome um parÃ¢metro de seguranÃ§a $m$, geralmente considerado como o
tamanho da saÃ­da da funÃ§Ã£o de resumo criptogrÃ¡fico escolhido. Considere as
funÃ§Ãµes\footnote{Na prÃ¡tica, o esquema pode ser instanciado utilizando $\hh{}$
no lugar de $f$.} de mÃ£o Ãºnica $f : \binwds{m} \longrightarrow \binwds{m}$ e de
resumo criptogrÃ¡fico $\fhash{m}$.  Descreve-se abaixo o funcionamento do
esquema e discute-se algumas de suas caracterÃ­sticas.

\begin{enumerate}

  \item[] \emph{GeraÃ§Ã£o de chaves.} Defina $\sk{} = (x_{0, m-1}, x_{1, m-1},
      \dots, x_{0,0}, x_{1,0}) \stackrel{\$}{\longleftarrow} \binwds{m}$ como a
        chave privada, informalmente uma $2m$-tupla de inteiros
        pseudoaleatÃ³rios. A chave pÃºblica $\pk{} = (y_{0, m-1}, y_{1, m-1},
        \dots, y_{0,0}, y_{1,0})$ Ã© derivada de $\sk{}$, computando $f(x) \;
        \forall x \in  \sk{}$. Logo, $\pk{} = (f(x_{0, m-1}), f(x_{1, m-1}),
        \dots, f(x_{0,0}), f(x_{1,0}))$.

  \item[] \emph{GeraÃ§Ã£o da assinatura.} Tome uma mensagem $M$ e calcule o seu
      resumo $d = \hash{M}$. $d$ pode ser representado como $d_{m-1} \dots
        d_0$. A assinatura consiste de elementos de $\sk{}$ operados por $f$:
        $\sigma = (f(x_{d_{m-1}, m-1}), \dots, f(x_{d_0, 0}))$.

  \item[] \emph{VerificaÃ§Ã£o da assinatura.} Para assegurar a corretude da
      assinatura $\sigma$, todos os blocos de $\sigma$ precisam ser verificados
        separadamente atravÃ©s do recÃ¡lculo de $d = d_{m-1} \dots d_0$, para que
        os elementos corretos de $\pk{}$ sejam escolhidos.  Assim, $\sigma$
        estÃ¡ correta se $(\sigma_{m-1}, \dots, \sigma_0) = (y_{d_{m-1}, m-1},
        \dots, y_{d_{0}, 0})$.

\end{enumerate}

Ã necessÃ¡rio comentar que assinaturas produzidas por este esquema podem ser
forjadas, visto que Ã© possÃ­vel computar $f$ para os \emph{bits} da mensagem que
sÃ£o igual a zero. Assim, uma soma de verificaÃ§Ã£o representando a quantidade de
zeros na mensagem original tambÃ©m Ã© assinada e enviada ao recipiente,
adicionando apenas $m \cdot log_2(m)$ \emph{bits} na assinatura.  Esta
caracterÃ­stica serÃ¡ explicada em mais detalhes no prÃ³ximo esquema.

Ademais, uma otimizaÃ§Ã£o simples para reduzir o tamanho de $\sk{}$ pode
ser implementada atravÃ©s da utilizaÃ§Ã£o de um gerador de nÃºmeros
pseudoaleatÃ³rios criptograficamente seguro. Assim, mostra-se necessÃ¡rio apenas
guardar uma palavra de tamanho $m$ que age como a semente deste gerador. No
caso de $\pk{}$, basta guardar o resumo criptogrÃ¡fico de seus valores
concatenados. Reduzir o tamanho das assinaturas mostra-se mais difÃ­cil;
entretanto, a generalizaÃ§Ã£o deste esquema permite esta otimizaÃ§Ã£o.

\subsection{O esquema Winternitz}

A introduÃ§Ã£o de um parÃ¢metro que habilita compensar a criaÃ§Ã£o de chaves e
assinaturas menores com uma diminuiÃ§Ã£o no desempenho do esquema foi sugerida
por Winternitz e publicada por Merkle~\cite{Merkle:1989:CDS:118209.118230}.  O
esquema, referido como \textsc{Wots}, permite assinar mÃºltiplos \emph{bits} em
cada bloco da assinatura, generalizando a proposta de Lamport. Elabora-se a
definiÃ§Ã£o do esquema abaixo.

Um parÃ¢metro de seguranÃ§a $m$ Ã© necessÃ¡rio, como acima. O parÃ¢metro Winternitz,
da forma $w \in \mathbb{N}, w > 1$, tambÃ©m deve ser definido, que representa a
quantidade de \emph{bits} a serem assinados simultaneamente.  A partir destes,
calcula-se $$t_1 = \left\lceil \frac{m}{w} \right\rceil, \; t_2 = \left\lceil
\frac{\left\lfloor \log_2 t_1 \right\rfloor + 1 + w}{w} \right\rceil \text{ e }
t = t_1 + t_2,$$ que representarÃ£o, respectivamente, a quantidade de palavras
em base-$w$ na assinatura referente Ã  mensagem, Ã  soma de verificaÃ§Ã£o, e Ã 
quantidade total.  Por fim, considere as funÃ§Ãµes de mÃ£o Ãºnica $f : \binwds{m}
\longrightarrow \binwds{m}$ e de resumo criptogrÃ¡fico $\fhash{m}$.

\begin{enumerate}

  \item[] \emph{GeraÃ§Ã£o de chaves.} Defina $\sk{} = (x_{t-1}, \dots, x_0)
      \stackrel{\$}{\longleftarrow} \binwds{m}$ como a chave privada,
        informalmente uma $t$-tupla de inteiros pseudoaleatÃ³rios. A chave
        pÃºblica $\pk{} = (y_{t-1}, \dots, y_0)$ pode ser derivada de $\sk{}$,
        computando $f^{2^{w}-1}(x) \; \forall x \in  \sk{}$. Logo, $\pk{} =
        (f^{2^{w}-1}(x_{t-1}), \dots, f^{2^{w}-1}(x_0))$.

  \item[] \emph{GeraÃ§Ã£o da assinatura.} Tome uma mensagem $M$ e calcule o seu
      resumo $d = \hash{M}$. Por conveniÃªncia, escolhe-se $m$ ou $w$ de forma
        que $w \mid m$, mas podem ser concatenados zeros ao resumo para que
        isso seja satisfeito. $d$ Ã© dividido em uma $t_1$-tupla de palavras em
        base-$w$, $\mathcal{B}_1 = (b_{t-1}, \dots, b_{t-t_1})$.
        Adicionalmente, uma soma de verificaÃ§Ã£o Ã© calculada usando a
        representaÃ§Ã£o inteira dos elementos de $\mathcal{B}_1$: $c = \sum_{b
        \in \mathcal{B}_1} 2^w - 1 - b$. Novamente, $c$ pode ser arredondado
        com zeros atÃ© que $w \mid \length{c}$. Finalmente, $c$ Ã© dividido em
        uma $t_2$-tupla de palavras base-$w$, $\mathcal{B}_2 = (b_{t_2-1},
        \dots, b_0)$. Assim, $\mathcal{B} = \mathcal{B}_1 \cup \mathcal{B}_2$ e
        obtÃ©m-se a assinatura $\sigma = (f^{b_{t-1}}(x_{t-1}), \dots,
        f^{b_0}(x_0)).$

  \item[] \emph{VerificaÃ§Ã£o da assinatura.} Para assegurar a corretude da
      assinatura $\sigma$, todos os blocos $\sigma_i$ precisam ser verificados
        separadamente atravÃ©s do cÃ¡lculo das aplicaÃ§Ãµes restantes de $f$.
        Assim, computando $\mathcal{B}$ novamente, $\sigma$ estÃ¡ correta se
        $\pk{} = (f^{2^w - 1 - b_{t-1}}(\sigma_{t-1}), \dots, f^{2^w - 1 -
        b_0}(\sigma_0))$.

\end{enumerate}

Note que nÃ£o Ã© possÃ­vel decrementar valores $b_i \in \mathcal{B}$, pois isto
implicaria em achar uma prÃ©-imagem de $f$, o que Ã© computacionalmente inviÃ¡vel
em vista da restriÃ§Ã£o para $f$. EntÃ£o, resta apenas a tentativa da falsificaÃ§Ã£o
de $\sigma$ incrementando algum valor $b_i$. A soma de verificaÃ§Ã£o $c$ Ã©
necessÃ¡ria a fim de proteger o esquema contra este comportamento. Observe que,
em sua ausÃªncia, Ã© possÃ­vel que uma entidade maliciosa crie assinaturas
$\sigma'$ apenas calculando mais iteraÃ§Ãµes de $f$ em blocos da assinatura
$\sigma$. Entretanto, com a presenÃ§a de $c$, e consequentemente
$\mathcal{B}_2$, ao modificar um valor $b_j \in \mathcal{B}_1$, para que o
valor correto de $\mathcal{B}_2$ seja mantido, Ã© necessÃ¡rio que uma prÃ©-imagem
de algum bloco $b_k \in \mathcal{B}_2$ seja calculada. Analogamente, modificar
algum valor de $\mathcal{B}_2$ tambÃ©m tornarÃ¡ a verificaÃ§Ã£o da assinatura
impossÃ­vel.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[
    decoration={
      markings,
      mark= at position 0.5 with {\node[font=\scriptsize] {/};},
      mark= at position 0.5 with {\node[font=\scriptsize, yshift=10pt] {m};}
    }]
	\tikzstyle{arrowline}=[draw, -latex']
	\tikzstyle{abox}=[draw, minimum width=30pt, minimum height=30pt]

    \matrix[matrix of nodes, column sep=35pt, row sep=30pt] {
		\node [abox] (xt1) {$x_i$}; &
		\node (fst1) {$f(x_i)$}; &
		\node [abox] (st1) {$\sigma_i$}; &
		\node (fvt1) {$f(\sigma_i)$}; &
		\node [abox] (yt1) {$y_i$}; \\
    };

	\node[above = 5pt of xt1] (X) {$x_i \in X:$};
	\node[above = 5pt of st1] (S) {$\sigma_i \in \sigma:$};
	\node[above = 5pt of yt1] (Y) {$y_i \in Y:$};

 	\path[arrowline, postaction={decorate}] (xt1)      --      (xt1 -| fst1.west);
 	\path[arrowline, postaction={decorate}] (fst1.east |- st1)      --      (st1);
    \path[->] (fst1) edge  [loop above] node {\scriptsize$b_i$} ();
 	\path[arrowline, postaction={decorate}] (st1)      --      (st1 -| fvt1.west);
 	\path[arrowline, postaction={decorate}] (fvt1.east |- yt1)      --      (yt1);
    \path[->] (fvt1) edge  [loop above] node {\scriptsize$2^w - 1-b_i$} ();
  \end{tikzpicture}
  \caption{RepresentaÃ§Ã£o grÃ¡fica das etapas de assinatura e verificaÃ§Ã£o do \textsc{Wots}, para $0 \leq i < t$.}
  \label{fig:5}
\end{figure}



\todo[inline]{discussion about multicollision or multiuser idk, also other wots
schemes, comment about wots-t and lm and stuff}
% de acordo com o lafrance, tem esses esquemas aqui a mais, com essas vantagens, e serao descritos mais pra frente, mas todos sao bem parecidos tratando-se de _estrutura_ (basicamente so muda a f)

\subsection{\textsc{Wots+}}

O principal esquema variante do \textsc{Wots}, chamado de
\textsc{Wots+}~\cite{Hlsing2013}, tem como ideia principal a
reposiÃ§Ã£o de $f$ por uma famÃ­lia de funÃ§Ãµes $\mathcal{F}_k$, substituindo o
processo de iteraÃ§Ãµes sequenciais --- utilizando apenas uma funÃ§Ã£o --- do
esquema original. Esta caracterÃ­stica tambÃ©m permite uma prova de seguranÃ§a
mais simples, mas nÃ£o menos poderosa, que desconsidera a necessidade da
resistÃªncia Ã  colisÃµes de $f$.

Defina os parÃ¢metros $m, w$ e a partir destes, $t_1, t_2 \text{ e } t$, bem
como a funÃ§Ã£o de resumo criptogrÃ¡fico $\fhash{m}$ de maneira anÃ¡loga ao esquema
original. A famÃ­lia de funÃ§Ãµes que o \textsc{Wots+} utiliza Ã© definida por
$\mathcal{F}_k : \{f_k : \binwds{m} \longrightarrow \binwds{m} \mid k \in
\mathcal{K}_m\}$, ou seja, funÃ§Ãµes de mÃ£o Ãºnica sem compressÃ£o, e
$\mathcal{K}_m$ Ã© interpretado como o espaÃ§o de chaves. A partir desta famÃ­lia,
e de uma tupla de palavras pseudoaleatÃ³rias $r = (r_0, \dots, r_{2^w - 1})
\stackrel{\$}{\longleftarrow} \binwds{m}$, elabora-se a nova funÃ§Ã£o de iteraÃ§Ã£o
$c^{i}_{k}(x, r)$, definida recursivamente como
\begin{equation}
  \begin{split}
    c^{0}_{k}(x, r) &= x \\
    c^{i}_{k}(x, r) &= f_k(c^{i-1}_{k}(x, r) \oplus r_i).
  \end{split}
\end{equation}

\begin{enumerate}

  \item[] \emph{GeraÃ§Ã£o de chaves.} Defina $\sk{}$ e $r$ como tuplas de
      inteiros pseudoaleatÃ³rios, discutidos anteriormente. O algoritmo tambÃ©m
        deve escolher uma chave de funÃ§Ã£o $k \stackrel{\$}\longleftarrow
        \mathcal{K}$. Por fim, $\pk{} = (c^{2^w-1}_{k}(x_{t-1}, r), \dots,
        c^{0}_{k}(x, r))$.

  \item[] \emph{GeraÃ§Ã£o da assinatura.} Tome uma mensagem $M$, calcule o seu
      resumo $d = \hash{M}$ e a soma de verificaÃ§Ã£o $c$ correspondente,
        produzindo $\mathcal{B}$. As consideraÃ§Ãµes sobre preenchimento de $m$ e
        $c$ ainda se aplicam. Aplicando a nova funÃ§Ã£o de iteraÃ§Ã£o, tem-se
        $\sigma = (c^{b_{t - 1}}_{k}(x_{t-1}, r), \dots, c^{b_{0}}_{k}(x_{0},
        r))$.

  \item[] \emph{VerificaÃ§Ã£o da assinatura.} Novamente, Ã© necessÃ¡rio calcular
      $\mathcal{B}$ para obter as iteraÃ§Ãµes restantes atÃ© $\pk{}$. Note que as
        primeiras $b_i$ palavras de $r$ nÃ£o serÃ£o utilizadas. Assim, $\sigma$
        estÃ¡ correta se $\pk{} = (c^{2^{w} - 1 - b_{t - 1}}_{k}(\sigma_{t-1},
        r), \dots, c^{2^{w} - 1 - b_{0}}_{k}(\sigma_{0}, r))$.

\end{enumerate}

Note que Ã© possÃ­vel utilizar uma funÃ§Ã£o conhecida, como o AES, para as
iteraÃ§Ãµes de $f$. PorÃ©m, Ã© necessÃ¡rio adaptÃ¡-la para que respeite as
restriÃ§Ãµes impostas pelo esquema. Para que isto seja feito de maneira
a manter um nÃ­vel de seguranÃ§a suficiente, Ã© possÃ­vel empregar a construÃ§Ã£o
Matyas-Meyer-Oseas~\cite[9.41]{Menezes:1996:HAC:548089}.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[scale=0.25]
    \draw (-2, 5) rectangle node {$g$} ++(2, 2);
    \draw (0, 0) rectangle node {$E$} ++(4, 4);
    \draw (1.5, 4) -- ++(0.5,-0.7) -- ++(0.5, +0.7);
    \node[XOR] (x0) at (7,2) {};
    \draw[edge] (-4,2) node[left] {$x_{i}$} -- ++(4,0);
    \draw[edge] (4,2) -- (x0);
    \draw[edge] (x0) -- ++(3,0) node[right] {$h_{i}$};
    \draw[edge] (-2,2) -- ++(0,-3) -- ++(9,0) -- (x0);
    \draw[edge] (-4,6) node[left] {$h_{i-1}$} -- ++(2, 0);
    \draw[edge] (0, 6) -- ++(2, 0) -- ++(0, -2);
  \end{tikzpicture}
  \caption{RepresentaÃ§Ã£o grÃ¡fica da construÃ§Ã£o Matyas-Meyer-Oseas,
    adaptado de~\cite{TikZ:for:Cryptographers}.}
  \label{fig:6}
\end{figure}

Assuma uma cifra de blocos genÃ©rica $E_{k}$ parametrizada pela chave $k$, cujo
bloco tem um tamanho de $n$ bits. Tome um vetor de inicializaÃ§Ã£o $IV$ de
tamanho $n$, e uma funÃ§Ã£o $g$ que adapte sua entrada para chaves do tamanho
necessÃ¡rio por $E_{k}$. Deseja-se obter um resumo $h_k$ de tamanho $n$ que
represente uma palavra $x$, e que sua inversibilidade seja computacionalmente
inviÃ¡vel. Deste modo, $X = (x_0, \dots, x_{k - 1}), \forall x_i \in X,
\length{x_i} = n$, ou seja, divida $x$ em uma $t$-tupla cujos elementos tÃªm
tamanho $n$ --- preenchimento com zeros pode ser aplicado caso existam
elementos que desrespeitem esta regra. O resultado deste processo, observado
na Figura~\ref{fig:6}, Ã© definido recursivamente como
\begin{equation}
    \begin{split}
        h_0 &= IV, \\
        h_i &= E_{g(h_{i-1})}(x_i) \oplus x_i, 1 \leq i \leq t.
    \end{split}
\end{equation}

Utilizando este mÃ©todo, Ã© possÃ­vel integrar o AES junto ao \textsc{Wots+}, como
forma de executar iteraÃ§Ãµes para criar e verificar a assinatura, conforme
sugerido em~\cite[4.1]{Hlsing2013}, aproveitando implementaÃ§Ãµes em
hardware de rotinas relacionadas (como o conjunto de instruÃ§Ãµes AES-NI da
Intel), habilitando um grande ganho de desempenho no cÃ´mputo desta cifra.
Note que apenas esta versÃ£o do esquema pode beneficiar-se deste mÃ©todo,
em virtude dos elementos pseudoaleatÃ³rios $r$ aplicados em cada iteraÃ§Ã£o.
Do contrÃ¡rio, o mÃ©todo pode introduzir multicolisÃµes em \textsc{Wots},
efetivamente reduzindo sua seguranÃ§a total.

\section{Esquemas baseados em Ã¡rvores de Merkle}

A criaÃ§Ã£o de um par de chaves para cada mensagem, bem como a infraestrutura
necessÃ¡ria para relacionar mÃºltiplas chaves a uma entidade, podem tornar-se
processos extremamente onerosos. Desse modo, assim como esquemas de assinatura
digital clÃ¡ssicos, deseja-se que uma chave privada possa assinar mÃºltiplos
documentos. No contexto de esquemas baseados em funÃ§Ãµes de resumo
criptogrÃ¡fico, a estrutura de dados chamada de Ã¡rvore de Merkle, geralmente de
caracterÃ­stica binÃ¡ria e perfeita, pode ser aproveitada para tal.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \tikzset{every tree node/.style={align=center,anchor=north}}
    \Tree
      [.\node{$T_{0,0}$ \\ $\hash{T_{1,0} \concat T_{1,1}}$};
        [.\node{$T_{1, 0}$ \\ $\hash{T_{2, 0} \concat T_{2, 1}}$};
          [.{$T_{2, 0}$ \\ $\hash{\mathcal{D}_{0}}$}
            \edge[dashed, style={<-}] node {}; $\mathcal{D}_{0}$
          ]
          [.{$T_{2, 1}$ \\ $\hash{\mathcal{D}_{1}}$}
            \edge[dashed, style={<-}] node {}; $\mathcal{D}_{1}$
          ]
        ]
        [.\node{$T_{1, 1}$ \\ $\hash{T_{2, 2} \concat T_{2, 3}}$};
          [.{$T_{2, 2}$ \\ $\hash{\mathcal{D}_{2}}$}
            \edge[dashed, style={<-}] node {}; $\mathcal{D}_{2}$
          ]
          [.{$T_{2, 3}$ \\ $\hash{\mathcal{D}_{3}}$}
            \edge[dashed, style={<-}] node {}; $\mathcal{D}_{3}$
          ]
        ]
      ]
  \end{tikzpicture}
  \caption{RepresentaÃ§Ã£o grÃ¡fica de uma Ã¡rvore $T$, com altura $h = 2$.}
  \label{fig:4}
\end{figure}

De modo genÃ©rico, folhas de uma Ã¡rvore de Merkle sÃ£o construÃ­das a partir do
resumo criptogrÃ¡fico de dados que desejam ser inseridos nesta. EntÃ£o, pais
destas folhas computarÃ£o o resumo criptogrÃ¡fico do valor dos resumos de seus
filhos concatenados, repetindo este processo atÃ© que a raiz seja preenchida,
como na Figura~\ref{fig:4}. Considerando uma Ã¡rvore binÃ¡ria perfeita $T$ de
altura $h \in \mathbb{N}^{*}$, onde um nÃ³ $T_{i,j}$ Ã© o $j$-Ã©simo Ã  esquerda na
altura $i$, e uma funÃ§Ã£o de resumo criptogrÃ¡fico $\fhash{m}$. As folhas sÃ£o
construÃ­das a partir do resumo de qualquer dado $\mathcal{D}$, e seus nÃ³s
intermediÃ¡rios a partir das folhas:
\begin{equation}
  \begin{split}
    T_{h, k} &= \hash{\mathcal{D}_k}, 0 \leq k < 2^{h}, \text{ e } \\
    T_{i, j} &= \hash{T_{i + 1, 2j} \concat T_{i + 1, 2j + 1}},
      \; 0 \leq j < 2^{i}, \; h > i \geq 0.
  \end{split}
\end{equation}
Esta estrutura tambÃ©m pode ser utilizada para verificaÃ§Ã£o conjunta da
integridade de mÃºltiplos arquivos (por exemplo, em sistemas de arquivos),
visto que qualquer mudanÃ§a em um nÃ³ da
Ã¡rvore produzirÃ¡ um valor distinto na raiz quando calculado novamente,
descaracterizando a validade dos dados atrelados a esta.

\todo[inline]{short private keys, forward security, second pre-image resistance}

\subsection{O esquema de Merkle}

O primeiro esquema de assinatura digital baseado em Ã¡rvores de Merkle
\cite{Merkle:1989:CDS:118209.118230} recomenda a assinatura de atÃ© $2^{20}$
mensagens. Informalmente, os dados inseridos em suas folhas sÃ£o chaves pÃºblicas
de diferentes instÃ¢ncias de um esquema de assinatura Ãºnica, como \textsc{Wots}.
Assim, ao construir a Ã¡rvore de Merkle, a raiz serÃ¡ a chave pÃºblica deste
esquema, que validarÃ¡ todas as folhas da Ã¡rvore atravÃ©s de um caminho de
autenticaÃ§Ã£o. A chave privada pode ser descrita como o conjunto de chaves
privadas das folhas, e a assinatura consiste da mensagem assinada pela
instÃ¢ncia do esquema localizado em uma folha qualquer, bem como todos os nÃ³s
necessÃ¡rios para calcular o conteÃºdo da raiz da Ã¡rvore.

Formalmente, seja uma Ã¡rvore de Merkle $T$ com $h \geq 2$. Tome um esquema de
assinatura digital Ãºnica genÃ©rico \textsc{Ots}, suas chaves privada e pÃºblica
como, respectivamente, $\textsc{Ots}_{\sk{}}$ e $\textsc{Ots}_{\pk{}}$, e os
algoritmos de geraÃ§Ã£o de chaves, geraÃ§Ã£o de assinatura e verificaÃ§Ã£o de
assinatura como, respectivamente, $\textsc{Ots}_\mathcal{K},
\textsc{Ots}_\mathcal{S} \text{ e } \textsc{Ots}_\mathcal{V}$. Por fim,
considere uma funÃ§Ã£o de resumo criptogrÃ¡fico $\fhash{m}$.

\begin{enumerate}

  \item[] \emph{GeraÃ§Ã£o de chaves.} A chave privada Ã© definida como uma
      $2^{h}$-tupla de pares de chaves diferentes provenientes de \textsc{Ots}.
        EntÃ£o, a partir de execuÃ§Ãµes de $\textsc{Ots}_\mathcal{K}$ para cada
        folha, tem-se $\sk{} = ((\textsc{Ots}_{\sk{}}^{2^{h} - 1},
        \textsc{Ots}_{\pk{}}^{2^{h} - 1}), \dots, (\textsc{Ots}_{\sk{}}^{0},
        \textsc{Ots}_{\pk{}}^{0}))$. As folhas de $T$ sÃ£o preenchidas com as
        respectivas chaves pÃºblicas de \textsc{Ots}. Portanto, $T_{h, j} =
        \hash{\textsc{Ots}_{\pk{}}^{j}}, 0 \leq j < 2^{h}$, e $T$ Ã© construÃ­da
        recursivamente. Finalmente, $\pk{} = T_{0,0}$.

  \item[] \emph{GeraÃ§Ã£o da assinatura.} Tome uma mensagem $M$ e calcule o seu
      resumo $d = \hash{M}$. Escolha uma folha de Ã­ndice $j$ nÃ£o utilizada
        anteriormente e produza a assinatura $\textsc{Ots}_\sigma^{j} =
        \textsc{Ots}_\mathcal{S}(M)$. O caminho de autenticaÃ§Ã£o \textsc{Auth} Ã©
        uma $h$-tupla necessÃ¡ria para recriar os resumos desejados a fim de
        comparÃ¡-los com a raiz da Ã¡rvore, e tambÃ©m deve ser incluÃ­do na
        assinatura. Assim, de acordo com~\cite{Bernstein:2008:PQC:1522375},
        $\textsc{Auth}_k = T_{h - k, \lfloor \sfrac{j}{2^k} \rfloor + 1 - 2
        (\lfloor j/2^k \rfloor \pmod{2})}, 0 \leq k < h$. A assinatura final
        leva em conta todos estes itens. Portanto, $\sigma = (j,
        \textsc{Ots}_\sigma^{j}, \textsc{Ots}_{\pk{}}^{j}, \textsc{Auth})$.

  \item[] \emph{VerificaÃ§Ã£o da assinatura.} Para verificar uma assinatura
      perante a Ã¡rvore $T$, Ã© necessÃ¡rio primeiro verificar a assinatura Ãºnica.
        Caso $\textsc{Ots}_{\mathcal{V}}(\textsc{Ots}_{\pk{}}^{j},
        \textsc{Ots}_{\sigma}^{j}) = 1$, entÃ£o Ã© possÃ­vel reconstruir os nodos
        do caminho de autenticaÃ§Ã£o atravÃ©s da definiÃ§Ã£o recursiva abaixo:
        \begin{equation}
          \begin{split}
            a_{0} &= \hash{\textsc{Ots}_{\pk{}}^{j}} \text{ e } \\
            a_{k} &=
            \begin{cases}
              \hash{a_{k - 1} \concat \textsc{Auth}_{k - 1}}, \text{ se }
                \lfloor \sfrac{j}{2^{k - 1}} \rfloor \equiv 0 \pmod{2} \\
              \hash{\textsc{Auth}_{k - 1} \concat a_{k - 1}}, \text{ se }
                \lfloor \sfrac{j}{2^{k - 1}} \rfloor \equiv 1 \pmod{2} \\
            \end{cases} \text{ para } 1 \leq k \leq h.
          \end{split}
        \end{equation}
        Finalmente, se $\pk{} = a_{h}$, a assinatura estÃ¡ vÃ¡lida.

\end{enumerate}

Note que no passo de geraÃ§Ã£o da assinatura, um Ã­ndice da folha tem de ser escolhido, de modo que respeite uma restriÃ§Ã£o estrita: o nodo nÃ£o pode ter sido selecionado anteriormente, a fim de prevenir a reutilizaÃ§Ã£o de uma instÃ¢ncia de esquema de assinatura digital Ãºnica. Para que essa escolha seja bem sucedida, Ã© necessÃ¡rio que o esquema baseado em Ã¡rvores de Merkle coordene quais Ã­ndices foram utilizados. Este conceito Ã© chamado de gerenciamento de estado, e introduz vÃ¡rios obstÃ¡culos para o funcionamento do esquema~\cite{McGrew2016}, como a necessidade de salvar frequentemente informaÃ§Ãµes sobre o estado em armazenamento nÃ£o volÃ¡til. Ademais, este Ã© geralmente codificado em $\pk{}$, e portanto, duas mensagens nÃ£o podem ser assinadas com a mesma chave privada, criando problemas de sincronizaÃ§Ã£o de chaves entre mÃºltiplos dispositivos.

% https://iacr.org/archive/eurocrypt2004/30270536/szydlo-loglog.pdf
% The Merkle tree traversal problem is the task of finding an efficient algorithm
% to output this authentication data for successive leaves. The trivial solution
% of storing every node value in memory requires too much space. On the other
% hand, the approach of computing the authentication nodes on the round they are
% required will be very expensive for some nodes. The challenge is to conserve
% both space and computation by amortizing the cost of computing such expensive
% nodes.  Thus, this goal is different from other, more well known, tree
% traversal problems found in the literature.  In practice, Merkle trees have not
% been appealing due to the large amount of computation or storage required.
% However, with more efficient traversal techniques, Merkle trees may once again
% become more compelling, especially given the advantage that cryptographic
% constructions based on Merkle trees do not require any number theoretic
% assumptions.


\todo[inline]{comment about statefulness, some random notes about s ecurity,
traversal algorithms etc.}

\subsection{XMSS -- \emph{eXtended Merkle Signature Scheme}}

\todo[inline]{describe the scheme with figures, talk about rfc variants, allude
that we optimize these}

\subsection{XMSS multiÃ¡rvores}

\subsection{SPHINCS}

\todo[inline]{comment about modifications for sphincs+ but it's too much}

\chapter{OtimizaÃ§Ã£o do esquema Winternitz}

\section{DescriÃ§Ã£o das abordagens}

\todo[inline]{focus on the $R$ parameter, not the padding stuff that probably
was already proposed in LM-OTS}

\section{Resultados}

\bibliographystyle{alpha}
\bibliography{ref}

\end{document}
